#JAVA面试题
##面向对象和面向过程的区别  

###面向过程  
优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。  
缺点：没有面向对象易维护、易复用、易扩展  
###面向对象  
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护  
缺点：性能比面向过程低  
##JAVA语言有哪些特点
1、简单易学；
2、面向对象（封装，继承，多态）；  
3、平台无关性（ Java 虚拟机实现平台无关性）；  
4、可靠性；  
5、安全性；  
6、支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；  
7、支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；  
8、编译与解释并存；  
##关于 JVM JDK 和 JRE 最详细通俗的解答JVM  
Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
什么时字节码？采用字节码的好处是什么？
在Java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。JAVA语言通过字节码的方式，在一定程度上
解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以JAVA程序运行时比较高效，而且由于字节码并不专对一种特定的机器，
因此，Java程序无须重新编译便可在多种不同的计算机上运行。  
Java程序从源代码到运行一般有下面3步：
1、 .java文件（源代码）
2、然后再JDK中的javac编译，生成.class文件（JVM可理解的java字节）
3、然后再JVM里运行，生成可执行的二进制机器码
我们需要注意的时 .class -> 机器码 这一步。这一步jvm类加载器首先加载字节码文件，然后通过解释逐行解释执行，这种方式的执行速度会相对比较慢。
而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了JIT编译器，JIT属于运行时编译。当JIT编译器完成第一次编译后
，其余将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说
JAVA是编译与解释共存的语言。  
HotSpot采用了惰性评估（Lazy Ecaluation）的做法，根据二八鼎炉，消耗大部分系统资源的只有一小部分代码（热点代码），而这就是
JIT所需要编译的部分，JVM会根据代码每次被执行的情况手机信息并相应做出一些优化，因此执行的次数越多，它的速度就越快。JDK9
引入了一种新的编译模式AOT，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是
AOT编译器的编译质量是肯定比不上JIT编译器的。
 总结：JAVA虚拟机（JVM）是运行JAVA字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果
 。字节码和不同系统的JVM实现是java语言“一次编译。随处可以运行”的关键所在。
 ##JDK 和 JRE
 JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。  

 JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。  
 
 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。
 有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。
 那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。  
 
 ##Oracle JDK 和 OpenJDK 的对比
 可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么Oracle和OpenJDK之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。  
 
 对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护 。 
 关于JVM，JDK，JRE和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案：  
 问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？
 答：非常接近 --我们的Oracle JDK版本构建过程基于OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括Oracle的java插件和Java WebStart的实现。
 以及一些封装的源代码派对组件，如图形光栅化器，一些开源的第三方插件，如Rhino，以及零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源
 Oracle JDK的所有部分，除了我们考虑商业的部分。  
 总结：
 1、Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；  
 2、OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；  
 3、Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，
 如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 
 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；  
 4、在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；  
 5、Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；  
 6、Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。  
 
 ##Java和C++的区别
 1、都是面向对象的语言，都支持封装、继承和多态  
 2、Java 不提供指针来直接访问内存，程序内存更加安全  
 3、Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。  
 4、Java 有自动内存管理机制，不需要程序员手动释放无用内存  
 
 ##什么是 Java 程序的主类 应用程序和小程序的主类有何不同  
 一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，
 这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 
 public 类。主类是 Java 程序执行的入口点。  
 
 ##Java 应用程序与小程序之间有那些差别  
 简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。  
 
 ##字符型常量和字符串常量的区别
 1、形式上：字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符
 2、含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)  
 3、占内存大小 字符常量只占2个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节)

##构造器 Constructor 是否可被 override
在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。  

##重载和重写的区别  
重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 
重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

##Java 面向对象编程三大特性: 封装 继承 多态  
###封装  
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
###继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
注意：
1、子类拥有父类非 private 的属性和方法。
2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3、子类可以用自己的方式实现父类的方法
###多态
所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，
即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。  
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。  

## String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的  
###可变性  
简单的来说：String 类中使用 final 关键字字符数组保存字符串， private　final　char　value[]，所以 String 对象是不可变的。
而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串
char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。  

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。  

###线程安全性
String 中的对象是不可变的，也就可以理解为常量，线程安全。  
AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作， 
如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，
所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。  

###性能
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对
 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 
 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

总结：
1、操作少量的数据 = String
2、单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3、多线程操作字符串缓冲区下操作大量数据 = StringBuffer

##自动装箱与拆箱
装箱：将基本类型用它们对应的引用类型包装起来；  
拆箱：将包装类型转换为基本数据类型；  

##在一个静态方法内调用一个非静态成员为什么是非法的  
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

##在 Java 中定义一个不做事且没有参数的构造方法的作用
Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。
因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发
生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

##import java和javax有什么区别
刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展 
成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 
javax 包将成为标准API的一部分。

##接口和抽象类的区别是什么
1、接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法
2、接口中的实例变量默认是 final 类型的，而抽象类中则不一定
3、一个类可以实现多个接口，但最多只能实现一个抽象类
4、一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5、接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，
接口是行为的抽象，是一种行为的规范。
注意：备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，
接口中定义了一样的默认方法，必须重写，不然会报错。

##成员变量与局部变量的区别有那些
1、从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static
 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；
2、从变量在内存中的存储方式来看:如果成员变量是使用 static修饰的，那么这个成员变量是属于类的，如果没有使用使用 
  static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存
3、从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4、成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

## 创建一个对象用什么运算符?对象实体与对象引用有何不同?
new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0 
个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。

##什么是方法的返回值?返回值在类的方法里的作用是什么?
方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！

##一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

##构造方法有哪些特性
1、名字与类名相同；
2、没有返回值，但不能用void声明构造函数；
3、生成类的对象时自动执行，无需调用。

##静态方法和实例方法有何不同
1、在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2、静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.

##对象的相等与指向他们的引用相等,两者有什么不同?
对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

##在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?
帮助子类做初始化工作。

##== 与 equals(重要)
== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
1、情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
2、类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。


注意：String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

##hashCode 与 equals (重要) 你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？
###hashCode（）介绍
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

####为什么要有 hashCode？
我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：
当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode
值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）
方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到
其他位置。
 
####hashCode（）与equals（）的相关规定
 1、如果两个对象相等，则hashcode一定也是相同的
 2、两个对象相等,对两个对象分别调用equals方法都返回true
 3、两个对象有相同的hashcode值，它们也不一定是相等的
 4、因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
 5、hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等
 （即使这两个对象指向相同的数据）

##简述线程,程序,进程的基本概念.以及他们之间关系是什么?
###线程
线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线
程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为
如此，线程也被称为轻量级进程。
###程序
程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
###进程
进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的
过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源
如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进
程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会
相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内
几乎同时执行一个以上的程序段。

##线程有哪些基本状态
1 NEW 初始状态，线程被构建，但是还没有调用start()方法
2 RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”
3 BLOCKED 阻塞状态，表示线程阻塞于锁
4 WAITING 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或者中断）
5 TIME_WAITING 超时等待状态，该状态不用于WAITING,它是可以在指定地时间自行返回的
6 TERMINATERD 终止状态，表示当前线程已经执行完毕

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。
线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的
线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。

    操作系统隐藏Java虚拟机（JVM）中的RUNNABLE 和 RUNNING 状态，它只能看到RUNNABLE状态。所以Java系统一般将这两个状态统称
    为RUNNABLE 运行中状态

当线程执行wait()方法之后，线程进入WAITING 等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而
TIME_WAITING 超时等待 状态相当于在等待状态的基础上增加了超时超时限制，比如通过sleep（long millis）方法或wait(longmillis)
方法可以将Java线程置于TIMEDWAITING状态。当超时时间到达后Java线程将会返回到 RUNNABLE 状态。当线程调用同步方法时
，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的 run()方法之后将会进入到 TERMINATED
（终止） 状态。

##关于 final 关键字的一些总结
final关键字主要用在三个地方：变量、方法、类。
1、对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2、当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3、使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，
会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升
（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

##Java 中的异常处理
在JAVA中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时
 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，
 将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。
 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。
 这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。
 在 Java中，错误通过Error的子类描述。
 
 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。
 NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）
 和 ArrayIndexOutOfBoundsException （下标越界异常）。
 
 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。
 ###Throwable类常用方法
 1、public string getMessage():返回异常发生时的详细信息
 2、public string toString():返回异常发生时的简要描述
 3、public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
 4、public void printStackTrace():在控制台上打印Throwable对象封装的异常信息
 
###异常处理总结
1、try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
2、catch 块：用于处理try捕获到的异常。
3、finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

在以下4种特殊情况下，finally块不会被执行
1、在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
2、在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
3、程序所在的线程死亡。
4、关闭CPU。

如果try语句里有return，返回的是try语句块中变量值。 
详细执行过程如下：
1、如果有返回值，就把返回值保存到局部变量中；
2、执行jsr指令跳到finally语句里执行；
3、执行完finally语句后，返回之前保存在局部变量表里的值。
4、如果try，finally语句里均有return，忽略try的return，而使用finally的return.

##Java序列化中如果有些字段不想进行序列化 怎么办
对于不想进行序列化的变量，使用transient关键字修饰。

transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

##获取用键盘输入常用的的两种方法
1、通过 Scanner
2、通过 BufferedReader


原文转自：https://mp.weixin.qq.com/s/ccsui81-zvauLnfg5DViJw
